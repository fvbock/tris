package tris

import (
	zmq "github.com/alecthomas/gozmq"
	"github.com/fvbock/trie"
	// zpoll "github.com/tchap/gozmq-poller"
	"log"
	// "sync"
	"time"
)

type ServerConfig struct {
}

type Command struct {
}

const (
	STATE_STOP    = 1
	STATE_STOPPED = 2
	STATE_RUNNING = 3
)

type Server struct {
	Log *log.Logger

	// zeromq
	Host      string
	Port      int
	Context   *zmq.Context
	Socket    *zmq.Socket
	PollItems zmq.PollItems

	Databases map[string]*trie.RefCountTrie

	State         int
	Stateswitch   chan int
	CommandQueue  chan *Client
	ResponseQueue chan *Client
}

func New(logger *log.Logger) (s *Server, err error) {
	s = &Server{
		Log:           logger,
		Stateswitch:   make(chan int, 1),
		ResponseQueue: make(chan *Client),
	}
	return
}

// Think of REQ and DEALER sockets as "clients" and REP and ROUTER sockets as "servers". Mostly, you'll want to bind REP and ROUTER sockets, and connect REQ and DEALER sockets to them. It's not always going to be this simple, but it is a clean and memorable place to start.

func (s *Server) Start() {
	s.Stateswitch <- STATE_RUNNING
	go func(s *Server) {
		s.Log.Println("Starting server...")
		s.Context, _ = zmq.NewContext()
		s.Socket, _ = s.Context.NewSocket(zmq.ROUTER)
		s.Socket.SetSockOptInt(zmq.LINGER, 0)
		s.Socket.Bind("tcp://127.0.0.1:5000")

		s.Log.Println("Server started...")

		s.PollItems = zmq.PollItems{
			zmq.PollItem{Socket: s.Socket, Events: zmq.POLLIN},
		}

	loop:
		for {
			// _, _ = zmq.Poll(s.PollItems, 100)
			_, _ = zmq.Poll(s.PollItems, 0)
			switch {
			case s.PollItems[0].REvents&zmq.POLLIN != 0:
				id, _ := s.PollItems[0].Socket.Recv(zmq.SNDMORE)
				_, _ = s.PollItems[0].Socket.Recv(zmq.SNDMORE)
				msg, _ := s.PollItems[0].Socket.Recv(0)
				c := &Client{
					Id:  id,
					Msg: msg,
				}
				c.Response = append(c.Msg, []byte(" reply.")...)
				// go s.HandleClient(c)
				s.Log.Println("got msg:", c.Msg)
				s.PollItems[0].Socket.Send(c.Id, zmq.SNDMORE)
				s.PollItems[0].Socket.Send([]byte{0}, zmq.SNDMORE)
				s.PollItems[0].Socket.Send(c.Response, 0)
				s.Log.Println("sent reply:", c.Response)
			default:
				select {
				// case c := <-s.ResponseQueue:
				// s.Log.Println("send response", string(c.Response))
				// s.PollItems[0].Socket.Send(c.Id, zmq.SNDMORE)
				// s.PollItems[0].Socket.Send([]byte{0}, zmq.SNDMORE)
				// s.PollItems[0].Socket.Send(c.Response, 0)
				case s.State = <-s.Stateswitch:
					s.Log.Println("state changed:", s.State)
					if s.State == STATE_STOP {
						break loop
					}
					if s.State == STATE_RUNNING {
					}
				default:
					// s.Log.Println(".")
				}
			}
		}
		s.Log.Println("Server stopped running...")
		s.State = STATE_STOPPED
	}(s)
	s.Log.Println("Server starting...")
}

type Client struct {
	// HandlerSocket *zmq.Socket
	Id       []byte
	Msg      []byte
	Response []byte
}

func (s *Server) HandleClient(c *Client) {
	s.Log.Printf("handling client:%v\n", c)
	c.Response = append(c.Msg, []byte(" reply.")...)
	s.ResponseQueue <- c
}

/*
 */
// func (s *Server) HandleRequest(p *zmq.PollItem) {
// 	// id, _ := p.Socket.Recv(zmq.SNDMORE)
// 	// _, _ = p.Socket.Recv(zmq.SNDMORE)
// 	// msg, _ := p.Socket.Recv(0)
// 	// res := append(msg, []byte(" reply.")...)
// 	// s.Log.Printf("got msg: %v from %v\n", string(msg), id)
// 	// s.Log.Printf("will send reply: %v\n", string(res))
// 	// p.Socket.Send(id, zmq.SNDMORE)
// 	// p.Socket.Send([]byte{0}, zmq.SNDMORE)
// 	// p.Socket.Send(res, 0)
// }

/*
Take care of stuff...
*/
func (s *Server) prepareShutdown() {
}

func (s *Server) Stop() {
	s.Log.Println("Stopping server.")
	s.Stateswitch <- STATE_STOP
	for s.State != STATE_STOPPED {
		time.Sleep(100 * time.Millisecond)
	}
	s.Log.Println("Server teardown.")
	s.Socket.Close()
	s.Log.Println("Socket closed.")
	s.Context.Close()
	s.Log.Println("Context closed.")
	s.Log.Println("Stopped server.")
}
